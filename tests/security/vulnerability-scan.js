/**
 * MABOS Security Vulnerability Scanner
 * Comprehensive security testing suite following OWASP guidelines
 * Task 24: Security Testing Requirements
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configuration
const config = {
  baseUrl: process.env.BASE_URL || 'http://localhost:8000',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:3000',
  timeout: 30000,
  maxRetries: 3,
  outputDir: './security-reports',
};

// Security test results
const securityResults = {
  timestamp: new Date().toISOString(),
  vulnerabilities: [],
  summary: {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
  },
};

// Utility functions
const logger = {
  info: (msg) => console.log(`[INFO] ${msg}`),
  warn: (msg) => console.log(`[WARN] ${msg}`),
  error: (msg) => console.log(`[ERROR] ${msg}`),
  success: (msg) => console.log(`[SUCCESS] ${msg}`),
};

const addVulnerability = (severity, category, description, endpoint, details = {}) => {
  const vulnerability = {
    id: `MABOS-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    severity,
    category,
    description,
    endpoint,
    timestamp: new Date().toISOString(),
    details,
  };
  
  securityResults.vulnerabilities.push(vulnerability);
  securityResults.summary[severity]++;
  
  logger.warn(`${severity.toUpperCase()} vulnerability found: ${description}`);
};

// HTTP client with security headers analysis
const createSecureClient = () => {
  return axios.create({
    timeout: config.timeout,
    validateStatus: () => true, // Don't throw on any status code
    maxRedirects: 0, // Prevent redirect following for security tests
  });
};

// Security Tests

/**
 * Test 1: Security Headers Analysis
 */
async function testSecurityHeaders() {
  logger.info('Testing security headers...');
  const client = createSecureClient();
  
  try {
    const response = await client.get(config.baseUrl);
    const headers = response.headers;
    
    // Required security headers
    const requiredHeaders = {
      'x-content-type-options': 'nosniff',
      'x-frame-options': ['DENY', 'SAMEORIGIN'],
      'x-xss-protection': '1; mode=block',
      'strict-transport-security': null, // Should exist
      'content-security-policy': null,   // Should exist
      'referrer-policy': null,           // Should exist
    };
    
    for (const [header, expectedValue] of Object.entries(requiredHeaders)) {
      if (!headers[header]) {
        addVulnerability(
          'medium',
          'Missing Security Headers',
          `Missing ${header} header`,
          config.baseUrl,
          { header, recommendation: `Add ${header} header to prevent security vulnerabilities` }
        );
      } else if (Array.isArray(expectedValue) && !expectedValue.includes(headers[header])) {
        addVulnerability(
          'low',
          'Weak Security Headers',
          `Weak ${header} header value`,
          config.baseUrl,
          { header, currentValue: headers[header], recommendedValues: expectedValue }
        );
      }
    }
    
    // Check for information disclosure headers
    const disclosureHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];
    disclosureHeaders.forEach(header => {
      if (headers[header]) {
        addVulnerability(
          'info',
          'Information Disclosure',
          `Server information disclosed in ${header} header`,
          config.baseUrl,
          { header, value: headers[header] }
        );
      }
    });
    
  } catch (error) {
    logger.error(`Security headers test failed: ${error.message}`);
  }
}

/**
 * Test 2: Authentication Security
 */
async function testAuthenticationSecurity() {
  logger.info('Testing authentication security...');
  const client = createSecureClient();
  
  // Test weak passwords
  const weakPasswords = ['password', '123456', 'admin', 'test', ''];
  
  for (const password of weakPasswords) {
    try {
      const response = await client.post(`${config.baseUrl}/auth/login`, {
        username: 'admin',
        password: password,
      });
      
      if (response.status === 200) {
        addVulnerability(
          'critical',
          'Weak Authentication',
          `Weak password accepted: ${password}`,
          `${config.baseUrl}/auth/login`,
          { password, response: response.status }
        );
      }
    } catch (error) {
      // Expected for security
    }
  }
  
  // Test rate limiting
  const rapidRequests = Array(20).fill().map(() => 
    client.post(`${config.baseUrl}/auth/login`, {
      username: 'testuser',
      password: 'wrongpassword',
    })
  );
  
  try {
    const responses = await Promise.all(rapidRequests);
    const successfulRequests = responses.filter(r => r.status !== 429).length;
    
    if (successfulRequests > 10) {
      addVulnerability(
        'high',
        'Missing Rate Limiting',
        'No rate limiting on authentication endpoint',
        `${config.baseUrl}/auth/login`,
        { successfulRequests, totalRequests: 20 }
      );
    }
  } catch (error) {
    logger.error(`Rate limiting test failed: ${error.message}`);
  }
}

/**
 * Test 3: SQL Injection Testing
 */
async function testSQLInjection() {
  logger.info('Testing SQL injection vulnerabilities...');
  const client = createSecureClient();
  
  const sqlPayloads = [
    "' OR '1'='1",
    "'; DROP TABLE users; --",
    "' UNION SELECT * FROM users --",
    "1' OR '1'='1' --",
    "admin'--",
    "' OR 1=1#",
  ];
  
  const testEndpoints = [
    '/api/v1/users',
    '/api/v1/workflows',
    '/api/v1/search',
  ];
  
  for (const endpoint of testEndpoints) {
    for (const payload of sqlPayloads) {
      try {
        // Test in query parameters
        const response = await client.get(`${config.baseUrl}${endpoint}?search=${encodeURIComponent(payload)}`);
        
        if (response.data && typeof response.data === 'string') {
          if (response.data.includes('SQL') || response.data.includes('mysql') || response.data.includes('postgres')) {
            addVulnerability(
              'critical',
              'SQL Injection',
              'SQL injection vulnerability detected',
              `${config.baseUrl}${endpoint}`,
              { payload, response: response.data.substring(0, 200) }
            );
          }
        }
      } catch (error) {
        // Expected for security
      }
    }
  }
}

/**
 * Test 4: Cross-Site Scripting (XSS)
 */
async function testXSS() {
  logger.info('Testing XSS vulnerabilities...');
  const client = createSecureClient();
  
  const xssPayloads = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    'javascript:alert("XSS")',
    '<svg onload=alert("XSS")>',
    '"><script>alert("XSS")</script>',
  ];
  
  const testEndpoints = [
    '/api/v1/workflows',
    '/api/v1/users/profile',
  ];
  
  for (const endpoint of testEndpoints) {
    for (const payload of xssPayloads) {
      try {
        const response = await client.post(`${config.baseUrl}${endpoint}`, {
          name: payload,
          description: payload,
        });
        
        if (response.data && typeof response.data === 'string' && response.data.includes(payload)) {
          addVulnerability(
            'high',
            'Cross-Site Scripting (XSS)',
            'XSS vulnerability detected - unescaped user input',
            `${config.baseUrl}${endpoint}`,
            { payload }
          );
        }
      } catch (error) {
        // Expected for security
      }
    }
  }
}

/**
 * Test 5: API Security
 */
async function testAPISecurity() {
  logger.info('Testing API security...');
  const client = createSecureClient();
  
  // Test for exposed sensitive endpoints
  const sensitiveEndpoints = [
    '/admin',
    '/api/admin',
    '/api/v1/admin',
    '/debug',
    '/api/debug',
    '/config',
    '/api/config',
    '/health/detailed',
    '/metrics',
    '/api/internal',
  ];
  
  for (const endpoint of sensitiveEndpoints) {
    try {
      const response = await client.get(`${config.baseUrl}${endpoint}`);
      
      if (response.status === 200) {
        addVulnerability(
          'medium',
          'Exposed Sensitive Endpoint',
          `Sensitive endpoint accessible without authentication`,
          `${config.baseUrl}${endpoint}`,
          { status: response.status }
        );
      }
    } catch (error) {
      // Expected for security
    }
  }
  
  // Test HTTP methods
  const testEndpoint = `${config.baseUrl}/api/v1/workflows`;
  const methods = ['PUT', 'DELETE', 'PATCH', 'OPTIONS', 'TRACE'];
  
  for (const method of methods) {
    try {
      const response = await client.request({
        method,
        url: testEndpoint,
      });
      
      if (response.status < 400 && method === 'TRACE') {
        addVulnerability(
          'medium',
          'HTTP TRACE Method Enabled',
          'HTTP TRACE method is enabled, potential for XST attacks',
          testEndpoint,
          { method }
        );
      }
    } catch (error) {
      // Expected for security
    }
  }
}

/**
 * Test 6: File Upload Security
 */
async function testFileUploadSecurity() {
  logger.info('Testing file upload security...');
  const client = createSecureClient();
  
  const maliciousFiles = [
    { name: 'test.php', content: '<?php system($_GET["cmd"]); ?>', type: 'application/x-php' },
    { name: 'test.jsp', content: '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>', type: 'application/x-jsp' },
    { name: 'test.exe', content: 'MZ\x90\x00', type: 'application/x-msdownload' },
    { name: '../../../etc/passwd', content: 'root:x:0:0:root:/root:/bin/bash', type: 'text/plain' },
  ];
  
  for (const file of maliciousFiles) {
    try {
      const FormData = require('form-data');
      const form = new FormData();
      form.append('file', Buffer.from(file.content), {
        filename: file.name,
        contentType: file.type,
      });
      
      const response = await client.post(`${config.baseUrl}/api/v1/upload`, form, {
        headers: form.getHeaders(),
      });
      
      if (response.status === 200) {
        addVulnerability(
          'high',
          'Insecure File Upload',
          `Malicious file upload accepted: ${file.name}`,
          `${config.baseUrl}/api/v1/upload`,
          { filename: file.name, type: file.type }
        );
      }
    } catch (error) {
      // Expected for security
    }
  }
}

/**
 * Test 7: CORS Configuration
 */
async function testCORSConfiguration() {
  logger.info('Testing CORS configuration...');
  const client = createSecureClient();
  
  try {
    const response = await client.options(config.baseUrl, {
      headers: {
        'Origin': 'https://evil.com',
        'Access-Control-Request-Method': 'POST',
        'Access-Control-Request-Headers': 'Content-Type',
      },
    });
    
    const corsHeaders = response.headers;
    
    if (corsHeaders['access-control-allow-origin'] === '*') {
      addVulnerability(
        'medium',
        'Overly Permissive CORS',
        'CORS allows all origins (*)',
        config.baseUrl,
        { header: corsHeaders['access-control-allow-origin'] }
      );
    }
    
    if (corsHeaders['access-control-allow-credentials'] === 'true' && 
        corsHeaders['access-control-allow-origin'] === '*') {
      addVulnerability(
        'high',
        'Dangerous CORS Configuration',
        'CORS allows credentials with wildcard origin',
        config.baseUrl,
        { 
          allowOrigin: corsHeaders['access-control-allow-origin'],
          allowCredentials: corsHeaders['access-control-allow-credentials']
        }
      );
    }
  } catch (error) {
    logger.error(`CORS test failed: ${error.message}`);
  }
}

/**
 * Generate Security Report
 */
function generateSecurityReport() {
  logger.info('Generating security report...');
  
  // Ensure output directory exists
  if (!fs.existsSync(config.outputDir)) {
    fs.mkdirSync(config.outputDir, { recursive: true });
  }
  
  // Generate JSON report
  const jsonReport = path.join(config.outputDir, `security-report-${Date.now()}.json`);
  fs.writeFileSync(jsonReport, JSON.stringify(securityResults, null, 2));
  
  // Generate HTML report
  const htmlReport = generateHTMLReport();
  const htmlReportPath = path.join(config.outputDir, `security-report-${Date.now()}.html`);
  fs.writeFileSync(htmlReportPath, htmlReport);
  
  logger.success(`Security reports generated:`);
  logger.success(`JSON: ${jsonReport}`);
  logger.success(`HTML: ${htmlReportPath}`);
  
  // Print summary
  console.log('\n=== SECURITY SCAN SUMMARY ===');
  console.log(`Total vulnerabilities found: ${securityResults.vulnerabilities.length}`);
  console.log(`Critical: ${securityResults.summary.critical}`);
  console.log(`High: ${securityResults.summary.high}`);
  console.log(`Medium: ${securityResults.summary.medium}`);
  console.log(`Low: ${securityResults.summary.low}`);
  console.log(`Info: ${securityResults.summary.info}`);
  
  // Exit with error code if critical or high vulnerabilities found
  if (securityResults.summary.critical > 0 || securityResults.summary.high > 0) {
    process.exit(1);
  }
}

function generateHTMLReport() {
  return `
<!DOCTYPE html>
<html>
<head>
    <title>MABOS Security Scan Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f4f4f4; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .metric { background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 5px; text-align: center; }
        .critical { border-left: 5px solid #d32f2f; }
        .high { border-left: 5px solid #f57c00; }
        .medium { border-left: 5px solid #fbc02d; }
        .low { border-left: 5px solid #388e3c; }
        .info { border-left: 5px solid #1976d2; }
        .vulnerability { margin: 10px 0; padding: 15px; border-radius: 5px; }
        .details { background: #f9f9f9; padding: 10px; margin-top: 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>MABOS Security Scan Report</h1>
        <p>Generated: ${securityResults.timestamp}</p>
        <p>Total Vulnerabilities: ${securityResults.vulnerabilities.length}</p>
    </div>
    
    <div class="summary">
        <div class="metric critical">
            <h3>Critical</h3>
            <p>${securityResults.summary.critical}</p>
        </div>
        <div class="metric high">
            <h3>High</h3>
            <p>${securityResults.summary.high}</p>
        </div>
        <div class="metric medium">
            <h3>Medium</h3>
            <p>${securityResults.summary.medium}</p>
        </div>
        <div class="metric low">
            <h3>Low</h3>
            <p>${securityResults.summary.low}</p>
        </div>
        <div class="metric info">
            <h3>Info</h3>
            <p>${securityResults.summary.info}</p>
        </div>
    </div>
    
    <h2>Vulnerabilities</h2>
    ${securityResults.vulnerabilities.map(vuln => `
        <div class="vulnerability ${vuln.severity}">
            <h3>${vuln.category}</h3>
            <p><strong>Severity:</strong> ${vuln.severity.toUpperCase()}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            <p><strong>Endpoint:</strong> ${vuln.endpoint}</p>
            <div class="details">
                <pre>${JSON.stringify(vuln.details, null, 2)}</pre>
            </div>
        </div>
    `).join('')}
</body>
</html>
  `;
}

// Main execution
async function runSecurityScan() {
  logger.info('Starting MABOS security vulnerability scan...');
  
  try {
    await testSecurityHeaders();
    await testAuthenticationSecurity();
    await testSQLInjection();
    await testXSS();
    await testAPISecurity();
    await testFileUploadSecurity();
    await testCORSConfiguration();
    
    generateSecurityReport();
    
  } catch (error) {
    logger.error(`Security scan failed: ${error.message}`);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  runSecurityScan();
}

module.exports = {
  runSecurityScan,
  testSecurityHeaders,
  testAuthenticationSecurity,
  testSQLInjection,
  testXSS,
  testAPISecurity,
  testFileUploadSecurity,
  testCORSConfiguration,
}; 